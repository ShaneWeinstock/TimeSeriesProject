# summary by CC
#dataCC = data %>%  group_by(period,cost_center) %>% getSummary()
#write_csv(dataCC,'byCostCenter.csv')
dataTot = data  %>%
group_by(period) %>%
getSummary() %>% ungroup()
#write_csv(dataTot,'byMonth.csv')
x=dataTot$attritionRate
tswge::plotts.wge(x)
#tswge::plotts.wge(dataTot$attritionRate)
dataCC = data %>%  group_by(period,cost_center) %>% getSummary()
ggplot2::ggplot(data=filter(dataCC), aes(x=timeID, y=attritionRate) )+
ggplot2::geom_point(alpha=0.2,shape=16)  +
ggplot2::stat_summary(fun.y='mean',geom='line',color='red',size=1.2) +
ggplot2::scale_y_log10()
p=tswge::plotts.sample.wge(head(x,length(x)/2))
p=tswge::plotts.sample.wge(tail(x,length(x)/2))
p=tswge::plotts.sample.wge(x)
xtr=tswge::artrans.wge(x,phi.tr=c(rep(0,2),1))
p=tswge::plotts.sample.wge(xtr)
aic5 = tswge::aic5.wge(xtr,p=0:5,q=0:3,type='aic')
bic5 = tswge::aic5.wge(xtr,p=0:5,q=0:3,type='bic')
pacf(xtr)
p=tswge::plotts.sample.wge(xtr)
p=3;q=2;s=3
es=tswge::est.arma.wge(xtr,p=p,q=q)
es$phi
if(p>1) tswge::factor.wge(phi=es$phi)
es$theta
if(q>1) tswge::factor.wge(phi=es$theta)
m=tswge::fore.aruma.wge(x,phi = es$phi,theta=es$theta,s=s,n.ahead = 12,lastn = F,plot=F)
message('Variance: ',m$wnv)
message('Mean: ',mean(x))
ase = function(f,x){mean((f - tail(x,length(f)))^2)}
m = tswge::fore.aruma.wge(x,phi = es$phi,theta = es$theta,s=s,n.ahead = 12,lastn = T)
ase = ase(m$f,x)
message("ASE is: ",ase)
ase1=ase
asew=aseWindowed(x,phi=es$phi,theta = es$theta,s=s,horizon=12,numASEs = 30)
asew$plot
message("MEan Windowed ASE:",asew$meanASE)
aseW1=asew$meanASE
m1 = tswge::fore.aruma.wge(x,phi = es$phi,theta = es$theta,s=s,n.ahead = 12,lastn = F)
p=4;q=2;s=3
es=tswge::est.arma.wge(xtr,p=p,q=q)
es[c('phi','theta','avar')]
es$phi
if(p>1) tswge::factor.wge(phi=es$phi)
es$theta
if(q>1) tswge::factor.wge(phi=es$theta)
m=tswge::fore.aruma.wge(x,phi = es$phi,theta=es$theta,s=s,n.ahead = 12,lastn = F,plot=F)
message('Variance: ',m$wnv)
message('Mean: ',mean(x))
ase = function(f,x){mean((f - tail(x,length(f)))^2)}
m = tswge::fore.aruma.wge(x,phi = es$phi,theta = es$theta,s=s,n.ahead = 12,lastn = T)
ase = ase(m$f,x)
message("ASE is: ",ase)
ase2=ase
asew=aseWindowed(x,phi=es$phi,theta = es$theta,s=s,horizon=12,numASEs = 30)
asew$plot
message("MEan Windowed ASE:",asew$meanASE)
aseW2=asew$meanASE
m1 = tswge::fore.aruma.wge(x,phi = es$phi,theta = es$theta,s=s,n.ahead = 12,lastn = F)
p=3;q=0;s=3
message("Finding p using MLE:")
esM=tswge::est.ar.wge(xtr,p=p,type='mle')
message("Finding p using BURG:")
esB=tswge::est.ar.wge(xtr,p=p,type='burg')
es=esM
es$phi
m=tswge::fore.aruma.wge(x,phi = es$phi,s=s,n.ahead = 12,lastn = F,plot=F)
message('Variance: ',m$wnv)
message('Mean: ',mean(x))
ase = function(f,x){mean((f - tail(x,length(f)))^2)}
m = tswge::fore.aruma.wge(x,phi = es$phi,s=s,n.ahead = 12,lastn = T)
ase = ase(m$f,x)
message("ASE is: ",ase)
ase3=ase
asew=aseWindowed(x,phi=es$phi,theta = 0,s=s,horizon=12,numASEs = 30)
asew$plot
message("MEan Windowed ASE:",asew$meanASE)
aseW3=asew$meanASE
m1 = tswge::fore.aruma.wge(x,phi = es$phi,s=s,n.ahead = 12,lastn = F)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(tswge)
aseWindowed = function(x,phi=0,theta=0,s=0,d=0,horizon,trainingSize=NULL,numASEs = NULL,plot = F){
# horizon = width of each prediction window
# trainingSize = width of the training windows. If this is not provided, it will be calculated based on the numASEs parameter
# numASEs = number of windows to use. If provided, it is used to calculate the trainingSize
# all other parameters follows the paramteres of the tswge::fore.aruma.wfe function
#
library(ggplot2)
n=length(x)
if(!is.null(numASEs))  {trainingSize = n  - horizon +1 -numASEs }
if(is.null(trainingSize)) {message("Missing numASEs or Training Size");return(NULL)}
#calculating windows
windows=1:(n-(trainingSize + horizon) + 1)
#function to caluclate the windows (sapply is faster and more efficient than for loop)
ASEOut = sapply(windows,function(i){
#calculating the current window parameters
winStart = i
winEnd = (i+(trainingSize-1))
horStart = winEnd+1
horEnd = horStart + horizon-1
#calculating the forecasts with the  aruma function
f = tswge::fore.aruma.wge(x[winStart:winEnd],phi = phi, theta = theta, s = s, d = d
,n.ahead = horizon,plot=F)
#calculating the ASE for current windows
ASE = mean((x[horStart:horEnd] - f$f)^2)
#storing data for the Ploy
plotData = data.frame(windowNum = rep(i,horizon), forecast = f$f,time = horStart:horEnd)
return(list(ASE=ASE,plotData=plotData))
})
#combining the output from the sapply in two variables
plotData= reduce(ASEOut['plotData',],rbind) #for the plot
ASEs = reduce(ASEOut['ASE',],c) #for calculating the mean ASE
#calculating the plot
p=ggplot2::ggplot(data=plotData,aes(x=time,y=forecast,group=windowNum,color=windowNum)) +
geom_line(alpha=0.5) +
geom_line(data=data.frame(x=x,t=1:length(x)),aes(x=t,y=x),inherit.aes = F,color='red') +
ggplot2::ylab('Values') +
ggplot2::ggtitle("Actual Value and Rolling Windows Forecasts")
if(plot)  plot(p)
#returning everyyhing as a list
return(list(ASEs = ASEs
,meanASE = mean(ASEs)
,windows = windows
,windowsSize = trainingSize
,plot=p
,plotData = plotData
))
}
data = readRDS('TO_cc_data.rds') %>%
filter(snap_fiscal_month_sort >= 201001
,snap_fiscal_month_sort <= 201909) %>%
rename(period = snap_fiscal_month_sort)  %>%
arrange(period)
data$timeID = group_indices(data,period)
# Summaries
getSummary = function(x){x %>%
summarise(separationsCount = sum(cnt_non_RIF_separations,na.rm=T)
,attritionRate = sum(cnt_non_RIF_separations,na.rm=T)/sum(headcount,na.rm=T)
,headcount = sum(headcount,na.rm=T)
,ageMeanYrs = sum(tot_age,na.rm=T)/sum(headcount,na.rm=T)/12
,tenureMeanYrs = sum(tot_tenure,na.rm=T)/sum(headcount,na.rm=T)/12
,recognitionEvents = sum(spot_events+points_events+star_events,na.rm=T)
,supervisorsCount = sum(cnt_spvs,na.rm=T)
,lowPerffCount = sum(tot_ppa_low,na.rm=T)
,highPerfCount = sum(tot_ppa_high,na.rm=T)
,timeID = max(timeID)
)
}
# summary by CC
#dataCC = data %>%  group_by(period,cost_center) %>% getSummary()
#write_csv(dataCC,'byCostCenter.csv')
dataTot = data  %>%
group_by(period) %>%
getSummary() %>% ungroup()
#write_csv(dataTot,'byMonth.csv')
x=dataTot$attritionRate
tswge::plotts.wge(x)
#tswge::plotts.wge(dataTot$attritionRate)
dataCC = data %>%  group_by(period,cost_center) %>% getSummary()
ggplot2::ggplot(data=filter(dataCC), aes(x=timeID, y=attritionRate) )+
ggplot2::geom_point(alpha=0.2,shape=16)  +
ggplot2::stat_summary(fun.y='mean',geom='line',color='red',size=1.2) +
ggplot2::scale_y_log10()
p=tswge::plotts.sample.wge(head(x,length(x)/2))
p=tswge::plotts.sample.wge(tail(x,length(x)/2))
p=tswge::plotts.sample.wge(x)
xtr=tswge::artrans.wge(x,phi.tr=c(rep(0,5),1))
p=tswge::plotts.sample.wge(xtr)
xtr=tswge::artrans.wge(x,phi.tr=c(c(0,0,1,0,0,1),1))
p=tswge::plotts.sample.wge(xtr)
aic5 = tswge::aic5.wge(xtr,p=0:5,q=0:3,type='aic')
bic5 = tswge::aic5.wge(xtr,p=0:5,q=0:3,type='bic')
aic5
bic5
xtr=tswge::artrans.wge(x,phi.tr=c(c(0,0,1),1))
p=tswge::plotts.sample.wge(xtr)
p=tswge::plotts.sample.wge(xtr)
xtr=tswge::artrans.wge(x,phi.tr=c(c(0,0,1),1))
xtr=tswge::artrans.wge(x,phi.tr=c(0,0,1))
p=tswge::plotts.sample.wge(xtr)
xtr=tswge::artrans.wge(x,phi.tr=c(0,0,1,0,0,1))
p=tswge::plotts.sample.wge(xtr)
aic5 = tswge::aic5.wge(xtr,p=0:5,q=0:3,type='aic')
bic5 = tswge::aic5.wge(xtr,p=0:5,q=0:3,type='bic')
aic5
bic5
xtr=tswge::artrans.wge(x,phi.tr=c(0,0,1))
xtr=tswge::artrans.wge(x,phi.tr=c(0,0,1,0,0,1))
xtr=tswge::artrans.wge(x,phi.tr=c(0,0,1))
xtr=tswge::artrans.wge(x,phi.tr=c(0,0,0,0,0,1))
xtr=tswge::artrans.wge(x,phi.tr=c(0,0,1))
p=tswge::plotts.sample.wge(xtr)
aic5 = tswge::aic5.wge(xtr,p=0:5,q=0:3,type='aic')
bic5 = tswge::aic5.wge(xtr,p=0:5,q=0:3,type='bic')
aic5
bic5
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(tswge)
aseWindowed = function(x,phi=0,theta=0,s=0,d=0,horizon,trainingSize=NULL,numASEs = NULL,plot = F){
# horizon = width of each prediction window
# trainingSize = width of the training windows. If this is not provided, it will be calculated based on the numASEs parameter
# numASEs = number of windows to use. If provided, it is used to calculate the trainingSize
# all other parameters follows the paramteres of the tswge::fore.aruma.wfe function
#
library(ggplot2)
n=length(x)
if(!is.null(numASEs))  {trainingSize = n  - horizon +1 -numASEs }
if(is.null(trainingSize)) {message("Missing numASEs or Training Size");return(NULL)}
#calculating windows
windows=1:(n-(trainingSize + horizon) + 1)
#function to caluclate the windows (sapply is faster and more efficient than for loop)
ASEOut = sapply(windows,function(i){
#calculating the current window parameters
winStart = i
winEnd = (i+(trainingSize-1))
horStart = winEnd+1
horEnd = horStart + horizon-1
#calculating the forecasts with the  aruma function
f = tswge::fore.aruma.wge(x[winStart:winEnd],phi = phi, theta = theta, s = s, d = d
,n.ahead = horizon,plot=F)
#calculating the ASE for current windows
ASE = mean((x[horStart:horEnd] - f$f)^2)
#storing data for the Ploy
plotData = data.frame(windowNum = rep(i,horizon), forecast = f$f,time = horStart:horEnd)
return(list(ASE=ASE,plotData=plotData))
})
#combining the output from the sapply in two variables
plotData= reduce(ASEOut['plotData',],rbind) #for the plot
ASEs = reduce(ASEOut['ASE',],c) #for calculating the mean ASE
#calculating the plot
p=ggplot2::ggplot(data=plotData,aes(x=time,y=forecast,group=windowNum,color=windowNum)) +
geom_line(alpha=0.5) +
geom_line(data=data.frame(x=x,t=1:length(x)),aes(x=t,y=x),inherit.aes = F,color='red') +
ggplot2::ylab('Values') +
ggplot2::ggtitle("Actual Value and Rolling Windows Forecasts")
if(plot)  plot(p)
#returning everyyhing as a list
return(list(ASEs = ASEs
,meanASE = mean(ASEs)
,windows = windows
,windowsSize = trainingSize
,plot=p
,plotData = plotData
))
}
data = readRDS('TO_cc_data.rds') %>%
filter(snap_fiscal_month_sort >= 201001
,snap_fiscal_month_sort <= 201909) %>%
rename(period = snap_fiscal_month_sort)  %>%
arrange(period)
data$timeID = group_indices(data,period)
# Summaries
getSummary = function(x){x %>%
summarise(separationsCount = sum(cnt_non_RIF_separations,na.rm=T)
,attritionRate = sum(cnt_non_RIF_separations,na.rm=T)/sum(headcount,na.rm=T)
,headcount = sum(headcount,na.rm=T)
,ageMeanYrs = sum(tot_age,na.rm=T)/sum(headcount,na.rm=T)/12
,tenureMeanYrs = sum(tot_tenure,na.rm=T)/sum(headcount,na.rm=T)/12
,recognitionEvents = sum(spot_events+points_events+star_events,na.rm=T)
,supervisorsCount = sum(cnt_spvs,na.rm=T)
,lowPerffCount = sum(tot_ppa_low,na.rm=T)
,highPerfCount = sum(tot_ppa_high,na.rm=T)
,timeID = max(timeID)
)
}
# summary by CC
#dataCC = data %>%  group_by(period,cost_center) %>% getSummary()
#write_csv(dataCC,'byCostCenter.csv')
dataTot = data  %>%
group_by(period) %>%
getSummary() %>% ungroup()
#write_csv(dataTot,'byMonth.csv')
x=dataTot$attritionRate
tswge::plotts.wge(x)
#tswge::plotts.wge(dataTot$attritionRate)
dataCC = data %>%  group_by(period,cost_center) %>% getSummary()
ggplot2::ggplot(data=filter(dataCC), aes(x=timeID, y=attritionRate) )+
ggplot2::geom_point(alpha=0.2,shape=16)  +
ggplot2::stat_summary(fun.y='mean',geom='line',color='red',size=1.2) +
ggplot2::scale_y_log10()
p=tswge::plotts.sample.wge(head(x,length(x)/2))
p=tswge::plotts.sample.wge(tail(x,length(x)/2))
p=tswge::plotts.sample.wge(x)
xtr=tswge::artrans.wge(x,phi.tr=c(0,0,1))
p=tswge::plotts.sample.wge(xtr)
aic5 = tswge::aic5.wge(xtr,p=0:5,q=0:3,type='aic')
bic5 = tswge::aic5.wge(xtr,p=0:5,q=0:3,type='bic')
tswge::factor.wge(phi=c(0,0,1))
tswge::est.ar.wge(x,p=8,type='burg'])
tswge::factor.wge(phi=c(0,0,1))
tswge::est.ar.wge(x,p=8,type='burg')
tswge::factor.wge(phi=c(0,0,0,1))
tswge::est.ar.wge(x,p=8,type='burg')
tswge::factor.wge(phi=c(rep(0,4),1))
tswge::est.ar.wge(x,p=8,type='burg')
tswge::factor.wge(phi=c(rep(0,5),1))
tswge::est.ar.wge(x,p=8,type='burg')
tswge::factor.wge(phi=c(rep(0,11),1))
tswge::est.ar.wge(x,p=8,type='burg')
tswge::factor.wge(phi=c(rep(0,5),1))
tswge::est.ar.wge(x,p=8,type='burg')
tswge::factor.wge(phi=c(rep(0,5),1))
tswge::factor.wge(phi=c(rep(0,3),1))
tswge::est.ar.wge(x,p=8,type='burg')
tswge::factor.wge(phi=c(rep(0,5),1))
tswge::factor.wge(phi=c(rep(0,3),1))
e=tswge::est.ar.wge(x,p=8,type='burg')
xtr=tswge::artrans.wge(x,phi.tr=c(rep(0,5),1))
p=tswge::plotts.sample.wge(xtr)
aic5 = tswge::aic5.wge(xtr,p=0:5,q=0:3,type='aic')
bic5 = tswge::aic5.wge(xtr,p=0:5,q=0:3,type='bic')
aic5
bic5
pacf(xtr)
p=tswge::plotts.sample.wge(xtr)
xtr=tswge::artrans.wge(x,phi.tr=c(rep(0,5),1))
tswge::factor.wge(phi=c(rep(0,5),1))
tswge::factor.wge(phi=c(rep(0,2),1))
e=tswge::est.ar.wge(x,p=8,type='burg')
aic5 = tswge::aic5.wge(xtr,p=0:9,q=0:3,type='aic')
bic5 = tswge::aic5.wge(xtr,p=0:9,q=0:3,type='bic')
aic5
bic5
tswge::factor.wge(phi=c(rep(0,2),1))
e=tswge::est.ar.wge(x,p=8,type='burg')
tswge::factor.wge(phi=c(rep(0,5),1))
tswge::factor.wge(phi=c(rep(0,2),1))
e=tswge::est.ar.wge(x,p=8,type='burg')
tswge::factor.wge(phi=c(rep(0,5),1))
tswge::factor.wge(phi=c(rep(0,2),1))
e=tswge::est.ar.wge(x,p=10,type='burg')
xtr=tswge::artrans.wge(x,phi.tr=c(rep(0,2),1))
p=tswge::plotts.sample.wge(xtr)
aic5 = tswge::aic5.wge(xtr,p=0:5,q=0:3,type='aic')
bic5 = tswge::aic5.wge(xtr,p=0:5,q=0:3,type='bic')
aic5
bic5
pacf(xtr)
aic5
bic5
p=3;q=2;s=3
es=tswge::est.arma.wge(xtr,p=p,q=q)
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(tswge)
aseWindowed = function(x,phi=0,theta=0,s=0,d=0,horizon,trainingSize=NULL,numASEs = NULL,plot = F){
# horizon = width of each prediction window
# trainingSize = width of the training windows. If this is not provided, it will be calculated based on the numASEs parameter
# numASEs = number of windows to use. If provided, it is used to calculate the trainingSize
# all other parameters follows the paramteres of the tswge::fore.aruma.wfe function
#
library(ggplot2)
n=length(x)
if(!is.null(numASEs))  {trainingSize = n  - horizon +1 -numASEs }
if(is.null(trainingSize)) {message("Missing numASEs or Training Size");return(NULL)}
#calculating windows
windows=1:(n-(trainingSize + horizon) + 1)
#function to caluclate the windows (sapply is faster and more efficient than for loop)
ASEOut = sapply(windows,function(i){
#calculating the current window parameters
winStart = i
winEnd = (i+(trainingSize-1))
horStart = winEnd+1
horEnd = horStart + horizon-1
#calculating the forecasts with the  aruma function
f = tswge::fore.aruma.wge(x[winStart:winEnd],phi = phi, theta = theta, s = s, d = d
,n.ahead = horizon,plot=F)
#calculating the ASE for current windows
ASE = mean((x[horStart:horEnd] - f$f)^2)
#storing data for the Ploy
plotData = data.frame(windowNum = rep(i,horizon), forecast = f$f,time = horStart:horEnd)
return(list(ASE=ASE,plotData=plotData))
})
#combining the output from the sapply in two variables
plotData= reduce(ASEOut['plotData',],rbind) #for the plot
ASEs = reduce(ASEOut['ASE',],c) #for calculating the mean ASE
#calculating the plot
p=ggplot2::ggplot(data=plotData,aes(x=time,y=forecast,group=windowNum,color=windowNum)) +
geom_line(alpha=0.5) +
geom_line(data=data.frame(x=x,t=1:length(x)),aes(x=t,y=x),inherit.aes = F,color='red') +
ggplot2::ylab('Values') +
ggplot2::ggtitle("Actual Value and Rolling Windows Forecasts")
if(plot)  plot(p)
#returning everyyhing as a list
return(list(ASEs = ASEs
,meanASE = mean(ASEs)
,windows = windows
,windowsSize = trainingSize
,plot=p
,plotData = plotData
))
}
data = readRDS('TO_cc_data.rds') %>%
filter(snap_fiscal_month_sort >= 201001
,snap_fiscal_month_sort <= 201909) %>%
rename(period = snap_fiscal_month_sort)  %>%
arrange(period)
data$timeID = group_indices(data,period)
# Summaries
getSummary = function(x){x %>%
summarise(separationsCount = sum(cnt_non_RIF_separations,na.rm=T)
,attritionRate = sum(cnt_non_RIF_separations,na.rm=T)/sum(headcount,na.rm=T)
,headcount = sum(headcount,na.rm=T)
,ageMeanYrs = sum(tot_age,na.rm=T)/sum(headcount,na.rm=T)/12
,tenureMeanYrs = sum(tot_tenure,na.rm=T)/sum(headcount,na.rm=T)/12
,recognitionEvents = sum(spot_events+points_events+star_events,na.rm=T)
,supervisorsCount = sum(cnt_spvs,na.rm=T)
,lowPerffCount = sum(tot_ppa_low,na.rm=T)
,highPerfCount = sum(tot_ppa_high,na.rm=T)
,timeID = max(timeID)
)
}
# summary by CC
#dataCC = data %>%  group_by(period,cost_center) %>% getSummary()
#write_csv(dataCC,'byCostCenter.csv')
dataTot = data  %>%
group_by(period) %>%
getSummary() %>% ungroup()
#write_csv(dataTot,'byMonth.csv')
x=dataTot$attritionRate
tswge::plotts.wge(x)
#tswge::plotts.wge(dataTot$attritionRate)
dataCC = data %>%  group_by(period,cost_center) %>% getSummary()
ggplot2::ggplot(data=filter(dataCC), aes(x=timeID, y=attritionRate) )+
ggplot2::geom_point(alpha=0.2,shape=16)  +
ggplot2::stat_summary(fun.y='mean',geom='line',color='red',size=1.2) +
ggplot2::scale_y_log10()
p=tswge::plotts.sample.wge(head(x,length(x)/2))
p=tswge::plotts.sample.wge(tail(x,length(x)/2))
p=tswge::plotts.sample.wge(x)
tswge::factor.wge(phi=c(rep(0,5),1))
tswge::factor.wge(phi=c(rep(0,2),1))
e=tswge::est.ar.wge(x,p=10,type='burg')
xtr=tswge::artrans.wge(x,phi.tr=c(rep(0,2),1))
p=tswge::plotts.sample.wge(xtr)
aic5 = tswge::aic5.wge(xtr,p=0:5,q=0:3,type='aic')
bic5 = tswge::aic5.wge(xtr,p=0:5,q=0:3,type='bic')
pacf(xtr)
p=tswge::plotts.sample.wge(xtr)
p=3;q=2;s=3
es=tswge::est.arma.wge(xtr,p=p,q=q)
es$phi
if(p>1) tswge::factor.wge(phi=es$phi)
es$theta
if(q>1) tswge::factor.wge(phi=es$theta)
message('Variance: ',es$avar)
message('Mean: ',mean(x))
ase = function(f,x){mean((f - tail(x,length(f)))^2)}
m = tswge::fore.aruma.wge(x,phi = es$phi,theta = es$theta,s=s,n.ahead = 12,lastn = T)
ase = ase(m$f,x)
message("ASE is: ",ase)
ase1=ase
asew=aseWindowed(x,phi=es$phi,theta = es$theta,s=s,horizon=12,numASEs = 30)
asew$plot
message("MEan Windowed ASE:",asew$meanASE)
aseW1=asew$meanASE
p=4;q=2;s=3
es=tswge::est.arma.wge(xtr,p=p,q=q)
es[c('phi','theta','avar')]
es$phi
if(p>1) tswge::factor.wge(phi=es$phi)
es$theta
if(q>1) tswge::factor.wge(phi=es$theta)
message('Variance: ',es$avar)
message('Mean: ',mean(x))
p=3;q=0;s=3
message("Finding p using MLE:")
esM=tswge::est.ar.wge(xtr,p=p,type='mle')
message("Finding p using BURG:")
esB=tswge::est.ar.wge(xtr,p=p,type='burg')
es=esM
es$phi
message('Variance: ',es$avar)
message('Mean: ',mean(x))
v=1:3
names(v)= c('a','b','c')
v[4]=4
names(v[4])
mylist = list(1,2,'v',4,5)
unlist(mylist)
x=NA
y=x/1
y
library(DescTools)
rawdata = c(rnorm(10,rnorm(10),rnorm(10),rnorm(10)))
rawdata = c(rnorm(10),rnorm(10),rnorm(10),rnorm(10))
fact=gl(4,10)
fact
xrange=tapply(rawdata,fact,range,simplify = T)
xrange
e = c(1,3,3,1,2)
a = data.frame(e=3:1,p=c('g','f','b'),pass=c(F,F,T))
car= match(e,a)
car
c1=c(1,2,3)
c2=c(4,5,6)
cbind(c1,c2)
c2=data.frame(c(4,5,6))
cbind(c1,c2)
x=c(2,4,3,5)
x[-1]
x[c(-1,0,0,0)]
x[c(-1,2,3,4)]
